<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scheduler WASM Demo</title>
  <style>
    table {
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5rem;
    }
    #output.error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>WASM Scheduler Demo</h1>

  <!-- Task creation form -->
  <section style="border: 1px solid #ccc; padding: 1rem; margin-bottom: 1rem;">
    <h2>Add a Task</h2>
    <label>
      Task Name:
      <input type="text" id="task-name" />
    </label>
    <br /><br />
    <label>
      Window Type:
      <select id="window-type">
        <option value="anchor" selected>Anchor</option>
        <option value="range">Range</option>
      </select>
    </label>
    <br /><br />

    <!-- Anchor fields (visible by default) -->
    <div id="anchor-inputs">
      <label>Anchor Time (HH:MM): <input type="text" id="anchor-time" value="09:00" /></label>
    </div>

    <!-- Range fields (hidden by default) -->
    <div id="range-inputs" style="display: none;">
      <label>Start (HH:MM): <input type="text" id="range-start" value="13:00" /></label>
      <br />
      <label>End (HH:MM): <input type="text" id="range-end" value="15:00" /></label>
    </div>

    <br />
    <button id="btn-add-task">Add Task</button>
  </section>

  <!-- Table of tasks (no raw JSON) -->
  <section style="border: 1px solid #ccc; padding: 1rem;">
    <h2>Task List</h2>
    <table id="task-table">
      <thead>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>Window Type</th>
          <th>Time(s)</th>
        </tr>
      </thead>
      <tbody><!-- Populated dynamically --></tbody>
    </table>

    <button id="btn-schedule">Solve!</button>
  </section>

  <section style="border:1px solid #ccc; padding:1rem; margin-top:1rem;">
    <h2>Schedule Result</h2>
    <!-- We’ll render an “error” if the solver returns a string that’s not valid JSON -->
    <div id="output" class=""></div>

    <table id="schedule-table" style="display:none;">
      <thead>
        <tr>
          <th>#</th>
          <th>Task Name</th>
          <th>Scheduled Time</th>
        </tr>
      </thead>
      <tbody><!-- Populated dynamically --></tbody>
    </table>
  </section>

  <script type="module">
    import init, { schedule_from_json } from "./scheduler_wasm.js";

    // We'll keep tasks in a JavaScript array:
    let tasks = [
      { name: "Task A", windows: [{ Anchor: 540 }] },        // 9:00
      { name: "Lunch",  windows: [{ Anchor: 720 }] },        // 12:00
      { name: "Task B", windows: [{ Range: [780, 900] }] }   // 13:00–15:00
    ];

    // Helper: parse "HH:MM" to integer minutes
    function parseHHMM(value) {
      const [hh, mm] = value.split(":").map(x => parseInt(x, 10));
      return hh * 60 + mm;
    }

    // Convert integer minutes back to "HH:MM"
    function formatMinutes(m) {
      const hh = Math.floor(m / 60);
      const mm = m % 60;
      return `${String(hh).padStart(2, "0")}:${String(mm).padStart(2, "0")}`;
    }

    // Render the task table
    function renderTasks() {
      const tbody = document.querySelector("#task-table tbody");
      tbody.innerHTML = ""; // clear old rows

      tasks.forEach((task, idx) => {
        const tr = document.createElement("tr");

        // Row # / ID
        const tdNum = document.createElement("td");
        tdNum.textContent = idx + 1;
        tr.appendChild(tdNum);

        // Name
        const tdName = document.createElement("td");
        tdName.textContent = task.name;
        tr.appendChild(tdName);

        // Window type
        const tdType = document.createElement("td");
        let wtype = "?";
        if (task.windows?.[0]?.Anchor !== undefined) {
          wtype = "Anchor";
        } else if (task.windows?.[0]?.Range !== undefined) {
          wtype = "Range";
        }
        tdType.textContent = wtype;
        tr.appendChild(tdType);

        // Times (for Anchor, 1 time; for Range, 2 times)
        const tdTime = document.createElement("td");
        if (wtype === "Anchor") {
          const anchorVal = task.windows[0].Anchor;
          tdTime.textContent = formatMinutes(anchorVal);
        } else if (wtype === "Range") {
          const rangeVals = task.windows[0].Range;
          tdTime.textContent = formatMinutes(rangeVals[0]) + " - " + formatMinutes(rangeVals[1]);
        }
        tr.appendChild(tdTime);

        tbody.appendChild(tr);
      });
    }

    // Add a new task based on form
    function addTask() {
      const nameField = document.getElementById("task-name");
      const nameVal = nameField.value.trim();
      if (!nameVal) {
        alert("Please enter a task name.");
        return;
      }

      const wtype = document.getElementById("window-type").value;

      if (wtype === "anchor") {
        const anchorVal = document.getElementById("anchor-time").value.trim();
        if (!anchorVal.match(/^\d{1,2}:\d{2}$/)) {
          alert("Anchor time must be in HH:MM format.");
          return;
        }
        const anchorMin = parseHHMM(anchorVal);

        tasks.push({
          name: nameVal,
          windows: [ { Anchor: anchorMin } ]
        });

      } else if (wtype === "range") {
        const startVal = document.getElementById("range-start").value.trim();
        const endVal   = document.getElementById("range-end").value.trim();

        if (!startVal.match(/^\d{1,2}:\d{2}$/) || !endVal.match(/^\d{1,2}:\d{2}$/)) {
          alert("Range times must be in HH:MM format.");
          return;
        }
        const startMin = parseHHMM(startVal);
        const endMin   = parseHHMM(endVal);
        if (endMin <= startMin) {
          alert("End time must be > start time.");
          return;
        }

        tasks.push({
          name: nameVal,
          windows: [ { Range: [startMin, endMin] } ]
        });
      }

      // Clear fields
      nameField.value = "";
      document.getElementById("anchor-time").value = "09:00";
      document.getElementById("range-start").value = "13:00";
      document.getElementById("range-end").value   = "15:00";

      renderTasks();
    }

    // Render the final schedule result in a table
    function renderScheduleResult(scheduleData) {
      const scheduleTable = document.getElementById("schedule-table");
      const tbody = scheduleTable.querySelector("tbody");
      tbody.innerHTML = "";

      scheduleData.forEach((item, idx) => {
        // Each item is [ "Task Name", minutes ] or ( "Task Name", f64 )
        const tr = document.createElement("tr");

        // # column
        const tdNum = document.createElement("td");
        tdNum.textContent = idx + 1;
        tr.appendChild(tdNum);

        // Task name
        const tdName = document.createElement("td");
        tdName.textContent = item[0] || "???";
        tr.appendChild(tdName);

        // Time
        const tdTime = document.createElement("td");
        const rawMinutes = item[1] || 0;
        // Convert f64 to integer minutes, just rounding
        const minutes = Math.round(rawMinutes);
        tdTime.textContent = formatMinutes(minutes);
        tr.appendChild(tdTime);

        tbody.appendChild(tr);
      });

      // Show the table
      scheduleTable.style.display = "table";
    }

    function solveSchedule() {
      // Convert tasks array to JSON string
      const jsonInput = JSON.stringify(tasks);

      // Call the WASM schedule function
      const result = schedule_from_json(jsonInput);

      // Check if the result is valid JSON
      let scheduleData = null;
      const outputEl = document.getElementById("output");
      outputEl.classList.remove("error");
      outputEl.textContent = "";

      try {
        // Attempt to parse the result as JSON (Vec<(String, f64)>) 
        scheduleData = JSON.parse(result);
      } catch (err) {
        // It's either an error message or "Infeasible"
        outputEl.classList.add("error");
        outputEl.textContent = result;
        // Hide schedule table if any
        document.getElementById("schedule-table").style.display = "none";
        return;
      }

      // If we got here, it's parsed successfully. Render the table of results.
      renderScheduleResult(scheduleData);
    }

    async function run() {
      await init(); // Load WASM

      // Set up form toggling (anchor vs range)
      const windowTypeEl = document.getElementById("window-type");
      windowTypeEl.onchange = () => {
        const typeVal = windowTypeEl.value;
        document.getElementById("anchor-inputs").style.display = (typeVal === "anchor") ? "block" : "none";
        document.getElementById("range-inputs").style.display  = (typeVal === "range")  ? "block" : "none";
      };

      // Hook up button events
      document.getElementById("btn-add-task").onclick = addTask;
      document.getElementById("btn-schedule").onclick = solveSchedule;

      // Render initial table
      renderTasks();
    }

    run();
  </script>
</body>
</html>
